<#@ template language="C#" linePragmas="false" #>
<#@ import namespace="Microsoft.Quantum.QsCompiler.BondSchemas.EntryPoint" #>
//------------------------------------------------------------------------------
// This code was generated by a tool.
// <auto-generated />
//------------------------------------------------------------------------------

#include <fstream>
#include <iostream>
#include <map>
#include <memory>
#include <vector>

#include "CLI11.hpp"

#include "QirRuntime.hpp"
#include "QirContext.hpp"

<# foreach (var header in SimulatorInitializer.Headers) { #>
#include "<#= header #>"
<# } #>

using namespace Microsoft::Quantum;
using namespace std;
<# if (EntryPoint.ContainsArgumentType(DataType.ArrayType)) { #>

// Auxiliary functions for interop with Q# Array type.
struct InteropArray
{
    int64_t Size;
    void* Data;

    InteropArray(int64_t size, void* data) :
        Size(size),
        Data(data){}
};

template<typename T>
unique_ptr<InteropArray> CreateInteropArray(vector<T>& v)
{
    unique_ptr<InteropArray> array(new InteropArray(v.size(), v.data()));
    return array;
}

template<typename S, typename D>
void TranslateVector(vector<S>& sourceVector, vector<D>& destinationVector, function<D(S&)> translationFunction)
{
    destinationVector.resize(sourceVector.size());
    transform(sourceVector.begin(), sourceVector.end(), destinationVector.begin(), translationFunction);
}
<# } #>
<# if (EntryPoint.ContainsArgumentType(DataType.RangeType) || EntryPoint.ContainsArrayType(DataType.RangeType)) { #>

// Auxiliary functions for interop with Q# Range type.
using RangeTuple = tuple<int64_t, int64_t, int64_t>;
struct InteropRange
{
    int64_t Start;
    int64_t Step;
    int64_t End;

    InteropRange() :
        Start(0),
        Step(0),
        End(0){}

    InteropRange(RangeTuple rangeTuple) :
        Start(get<0>(rangeTuple)),
        Step(get<1>(rangeTuple)),
        End(get<2>(rangeTuple)){}
};

unique_ptr<InteropRange> CreateInteropRange(RangeTuple rangeTuple)
{
    unique_ptr<InteropRange> range(new InteropRange(rangeTuple));
    return range;
}

InteropRange* TranslateRangeTupleToInteropRangePointer(RangeTuple& rangeTuple)
{
    InteropRange* range = new InteropRange(rangeTuple);
    return range;
}
<# } #>
<# if (EntryPoint.ContainsArrayType(DataType.RangeType)) { #>

// Auxiliary functions for interop with Q# Range[] type
template<typename T>
void FreePointerVector(vector<T*>& v)
{
    for (auto p : v)
    {
        delete p;
    }
}
<# } #>
<# if (EntryPoint.ContainsArgumentType(DataType.BoolType) || EntryPoint.ContainsArrayType(DataType.BoolType)) { #>

// Auxiliary functions for interop with Q# Bool type.
const char InteropFalseAsChar = 0x0;
const char InteropTrueAsChar = 0x1;
map<string, bool> <#= QirCppInterop.CliOptionTransformerMapName(DataType.BoolType) #>{
    {"0", InteropFalseAsChar},
    {"false", InteropFalseAsChar},
    {"1", InteropTrueAsChar},
    {"true", InteropTrueAsChar}
};
<# } #>
<# if (EntryPoint.ContainsArgumentType(DataType.PauliType) || EntryPoint.ContainsArrayType(DataType.PauliType)) { #>

// Auxiliary functions for interop with Q# Pauli type.
map<string, PauliId> <#= QirCppInterop.CliOptionTransformerMapName(DataType.PauliType) #>{
    {"PauliI", PauliId::PauliId_I},
    {"PauliX", PauliId::PauliId_X},
    {"PauliY", PauliId::PauliId_Y},
    {"PauliZ", PauliId::PauliId_Z}
};

char TranslatePauliToChar(PauliId& pauli)
{
    return static_cast<char>(pauli);
}
<# } #>
<# if (EntryPoint.ContainsArgumentType(DataType.ResultType) || EntryPoint.ContainsArrayType(DataType.ResultType)) { #>

// Auxiliary functions for interop with Q# Result type.
const char InteropResultZeroAsChar = 0x0;
const char InteropResultOneAsChar = 0x1;
map<string, char> <#= QirCppInterop.CliOptionTransformerMapName(DataType.ResultType) #>{
    {"0", InteropResultZeroAsChar},
    {"Zero", InteropResultZeroAsChar},
    {"1", InteropResultOneAsChar},
    {"One", InteropResultOneAsChar}
};
<# } #>
<# if (EntryPoint.ContainsArgumentType(DataType.StringType) || EntryPoint.ContainsArrayType(DataType.StringType)) { #>

// Auxiliary functions for interop with Q# String type.
const char* TranslateStringToCharBuffer(string& s)
{
    return s.c_str();
}
<# } #>

extern "C" void <#= EntryPoint.Name #>(
<# for (int i = 0; i < EntryPoint.Arguments.Count; i++) {
    var arg = EntryPoint.Arguments[i];
    var isLastArg = i == (EntryPoint.Arguments.Count-1); #>
    <#= arg.InteropType() #> <#= arg.Name #><#= (isLastArg) ? "" : "," #>
<# } #>
); // QIR interop function.

int main(int argc, char* argv[])
{
    CLI::App app("QIR Standalone Entry Point");

    // Initialize simulator.
<# foreach (var line in SimulatorInitializer.GenerateSourceCode()) { #>
    <#= line #>
<# } #>

    // Add the --simulation-output option.
    string simulationOutputFile;
    CLI::Option* simulationOutputFileOpt = app.add_option(
        "--simulation-output",
        simulationOutputFile,
        "File where the output produced during the simulation is written");

<# if (EntryPoint.Arguments.Count > 0) { #>
    // Add a command line option for each entry-point argument.
<# } #>
<# foreach (var arg in EntryPoint.Arguments) { #>
    <#= arg.CliOptionType() #> <#= arg.CliOptionVariableName() #>;
<# if (arg.CliOptionVariableDefaultValue() != null) { #>
    <#= arg.CliOptionVariableName() #> = <#= arg.CliOptionVariableDefaultValue() #>;
<# } #>
    app.add_option("<#= arg.CliOptionName() #>", <#= arg.CliOptionVariableName() #>, "<#= arg.CliOptionDescription() #>")
        ->required()<#= arg.CliOptionTransformerMapName() != null ? "" : ";" #>
<# if (arg.CliOptionTransformerMapName() != null) { #>
        ->transform(CLI::CheckedTransformer(<#= arg.CliOptionTransformerMapName() #>, CLI::ignore_case));
<# } #>

<# } #>
    // After all the options have been added, parse arguments from the command line.
    CLI11_PARSE(app, argc, argv);

<# if (EntryPoint.Arguments.Count > 0) { #>
    // Cast parsed arguments to its interop types.
<# } #>
<# foreach (var arg in EntryPoint.Arguments) { 
    var interopTranslator = QirCppInterop.CliOptionTypeToInteropTypeTranslator(arg.Type);#>
<# if (arg.Type == DataType.ArrayType) { 
    var arrayInteropTranslator = QirCppInterop.CliOptionTypeToInteropTypeTranslator(arg.ArrayType); #>
<# if (arrayInteropTranslator == null) { #>
    <#= arg.InteropType() #> <#= arg.InteropVariableName() #> = CreateInteropArray(<#= arg.CliOptionVariableName() #>).get();
<# } #>
<# else { 
    var arrayCliOptionType = QirCppInterop.CliOptionType(arg.ArrayType);
    var arrayInteropType = QirCppInterop.InteropType(arg.ArrayType); #>
    vector<<#= arrayInteropType #>> <#= arg.IntermediateVariableName() #>;
    TranslateVector<<#= arrayCliOptionType #>, <#= arrayInteropType #>>(<#= arg.CliOptionVariableName() #>, <#= arg.IntermediateVariableName() #>, <#= arrayInteropTranslator #>);
    <#= arg.InteropType() #> <#= arg.InteropVariableName() #> = CreateInteropArray(<#= arg.IntermediateVariableName() #>).get();
<# } #>
<# } #>
<# else if (interopTranslator == null) { #>
    <#= arg.InteropType() #> <#= arg.InteropVariableName() #> = <#= arg.CliOptionVariableName() #>;
<# } #>
<# else if (interopTranslator != null) { #>
    <#= arg.InteropType() #> <#= arg.InteropVariableName() #> = <#= interopTranslator #>(<#= arg.CliOptionVariableName() #>);
<# } #>

<# } #>
    // Redirect the simulator output from std::cout if the --simulation-output option is present.
    ostream* simulatorOutputStream = &cout;
    ofstream simulationOutputFileStream;
    if (!simulationOutputFileOpt->empty())
    {
        simulationOutputFileStream.open(simulationOutputFile);
        Microsoft::Quantum::OutputStream::Set(simulationOutputFileStream);
        simulatorOutputStream = &simulationOutputFileStream;
    }

    // Execute the entry point operation.
    <#= EntryPoint.Name #>(
<# for (int i = 0; i < EntryPoint.Arguments.Count; i++) {
    var arg = EntryPoint.Arguments[i];
    var isLastArg = i == (EntryPoint.Arguments.Count-1); #>
    <#= arg.InteropVariableName() #><#= (isLastArg) ? "" : "," #>
<# } #>
    );

    // Flush the output of the simulation.
    simulatorOutputStream->flush();
    if (simulationOutputFileStream.is_open())
    {
        simulationOutputFileStream.close();
    }

    return 0;
}
