// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

#include <bitset>
#include <cassert>
#include <iostream>
#include <memory>
#include <string>
#include <unordered_set>
#include <cstdint>

#define CATCH_CONFIG_MAIN // This tells Catch to provide a main() - only do this in one cpp file
#include "catch.hpp"

#include "qir_stdlib.h"

class QUBIT;

// Identifiers exposed externally:
extern "C" void __quantum__qis__k__body(QUBIT* q);                    // NOLINT
extern "C" void __quantum__qis__k__ctl(QirArray* controls, QUBIT* q); // NOLINT

using namespace std;

/*
Forward declared `extern "C"` methods below are implemented in the *.ll files. Most of the files are generated by Q#
compiler, in which case the corresponding *.qs file was used as a source. Some files might have been authored manually
or manually edited.

To update the *.ll files to a newer version:
- enlist and build qsharp-compiler
- find <location1>\qsc.exe and <location2>\QirCore.qs, <location2>\QirTarget.qs built files
- [if different] copy QirCore.qs and QirTarget.qs into the "compiler" folder
- run: qsc.exe build --qir s --build-exe --input name.qs compiler\qircore.qs compiler\qirtarget.qs --proj name
- the generated file name.ll will be placed into `s` folder
*/

struct Array // TODO(rokuzmin, #969): Document the mechanism of passing an array to the QIR generated from Q#.
{
    int64_t itemCount;
    void* buffer;
};

// The function replaces array[index] with value, then creates a new array that consists of every other element up to
// index (starting from index backwards) and every element from index to the end. It returns the sum of elements in this
// new array
extern "C" int64_t Microsoft__Quantum__Testing__QIR__Test_Arrays__Interop( // NOLINT
    Array* array, int64_t index, int64_t val);
TEST_CASE("QIR: Using 1D arrays", "[qir][qir.arr1d]")
{
    constexpr int64_t itemCount = 5;
    int64_t values[itemCount]   = {0, 1, 2, 3, 4};
    auto array                  = Array{itemCount, values};

    int64_t res = Microsoft__Quantum__Testing__QIR__Test_Arrays__Interop(&array, 2, 42);
    REQUIRE(res == (0 + 42) + (42 + 3 + 4));
}

extern "C" void Microsoft__Quantum__Testing__QIR__TestQubitResultManagement__Interop(); // NOLINT
TEST_CASE("QIR: allocating and releasing qubits and results", "[qir][qir.qubit][qir.result]")
{
    REQUIRE_NOTHROW(Microsoft__Quantum__Testing__QIR__TestQubitResultManagement__Interop());
}

// TestPartials subtracts the second argument from the first and returns the result.
extern "C" int64_t Microsoft__Quantum__Testing__QIR__TestPartials__Interop(int64_t, int64_t); // NOLINT
TEST_CASE("QIR: Partial application of a callable", "[qir][qir.partCallable]")
{
    const int64_t res = Microsoft__Quantum__Testing__QIR__TestPartials__Interop(42, 17);
    REQUIRE(res == 42 - 17);
}

// The Microsoft__Quantum__Testing__QIR__TestFunctors__Interop tests needs proper semantics of X and M, and nothing
// else. The validation is done inside the test and it would throw in case of failure.
extern "C" void __quantum__qis__x__body(QUBIT* q);                               // NOLINT
extern "C" void __quantum__qis__x__ctl(QirArray* controls, QUBIT* q);            // NOLINT
extern "C" void Microsoft__Quantum__Testing__QIR__TestFunctors__Interop();       // NOLINT
extern "C" void Microsoft__Quantum__Testing__QIR__TestFunctorsNoArgs__Interop(); // NOLINT
extern "C" void __quantum__qis__k__body(QUBIT* q)                                // NOLINT
{
    __quantum__qis__x__body(q);
}
extern "C" void __quantum__qis__k__ctl(QirArray* controls, QUBIT* q) // NOLINT
{
    __quantum__qis__x__ctl(controls, q);
}

TEST_CASE("QIR: application of nested controlled functor", "[qir][qir.functor]")
{
    CHECK_NOTHROW(Microsoft__Quantum__Testing__QIR__TestFunctors__Interop());
    CHECK_NOTHROW(Microsoft__Quantum__Testing__QIR__TestFunctorsNoArgs__Interop());
}
