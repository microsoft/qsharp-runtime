// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
#![deny(clippy::all, clippy::pedantic)]

use super::result_bool::{__quantum__rt__result_equal, __quantum__rt__result_get_one};

use qir_runtime::{
    __quantum__rt__fail,
    arrays::{QirArray, __quantum__rt__array_get_element_ptr_1d, __quantum__rt__array_get_size_1d},
    callables::{Callable, __quantum__rt__callable_invoke},
    strings::__quantum__rt__string_create,
};
use std::{
    ffi::{c_void, CString},
    ptr::null_mut,
};

/// # Safety
///
/// This function should only be called with results and callables generated by this runtime.
#[no_mangle]
pub unsafe extern "C" fn __quantum__qis__applyifelseintrinsic__body(
    result: *mut c_void,
    true_callable: *const Callable,
    false_callable: *const Callable,
) {
    __quantum__rt__callable_invoke(
        if __quantum__rt__result_equal(result, __quantum__rt__result_get_one()) {
            true_callable
        } else {
            false_callable
        },
        null_mut(),
        null_mut(),
    );
}

/// # Safety
///
/// This function should only be called with arrays of results and callables generated by this runtime.
#[no_mangle]
#[allow(clippy::cast_ptr_alignment)]
pub unsafe extern "C" fn __quantum__qis__applyconditionallyintrinsic__body(
    results: *const QirArray,
    expected: *const QirArray,
    true_callable: *const Callable,
    false_callable: *const Callable,
) {
    let result_len = __quantum__rt__array_get_size_1d(results);
    if result_len != __quantum__rt__array_get_size_1d(expected) {
        __quantum__rt__fail(__quantum__rt__string_create(
            CString::new(
                "Invalid Argument: expected and actual result arrays must have the same size.",
            )
            .expect("Unable to allocate string for error message.")
            .as_bytes_with_nul()
            .as_ptr() as *mut i8,
        ));
    }

    for index in 0..result_len {
        let res = *__quantum__rt__array_get_element_ptr_1d(results, index).cast::<*mut c_void>();
        let expect =
            *__quantum__rt__array_get_element_ptr_1d(expected, index).cast::<*mut c_void>();
        if !__quantum__rt__result_equal(res, expect) {
            // We've found a mismatch, so invoke false and early return.
            return __quantum__rt__callable_invoke(false_callable, null_mut(), null_mut());
        }
    }

    __quantum__rt__callable_invoke(true_callable, null_mut(), null_mut());
}
